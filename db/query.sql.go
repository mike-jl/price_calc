// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package db

import (
	"context"
)

const deleteIngredient = `-- name: DeleteIngredient :execrows
;

delete from ingredients
where (id = ?)
`

func (q *Queries) DeleteIngredient(ctx context.Context, id int64) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteIngredient, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getCategories = `-- name: GetCategories :many
;

select id, name, vat
from categories
`

func (q *Queries) GetCategories(ctx context.Context) ([]Category, error) {
	rows, err := q.db.QueryContext(ctx, getCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(&i.ID, &i.Name, &i.Vat); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategory = `-- name: GetCategory :one
;

select id, name, vat
from categories
where id = ?
`

func (q *Queries) GetCategory(ctx context.Context, id int64) (Category, error) {
	row := q.db.QueryRowContext(ctx, getCategory, id)
	var i Category
	err := row.Scan(&i.ID, &i.Name, &i.Vat)
	return i, err
}

const getIngredients = `-- name: GetIngredients :many
select i.id, name, ip.id, time_stamp, price, quantity, unit_id, ingredient_id
from ingredients i
left join ingredient_prices ip on ip.ingredient_id = i.id
order by i.name collate nocase asc, ip.time_stamp desc
`

type GetIngredientsRow struct {
	ID           int64
	Name         string
	ID_2         *int64
	TimeStamp    *int64
	Price        *float64
	Quantity     *float64
	UnitID       *int64
	IngredientID *int64
}

func (q *Queries) GetIngredients(ctx context.Context) ([]GetIngredientsRow, error) {
	rows, err := q.db.QueryContext(ctx, getIngredients)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetIngredientsRow
	for rows.Next() {
		var i GetIngredientsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ID_2,
			&i.TimeStamp,
			&i.Price,
			&i.Quantity,
			&i.UnitID,
			&i.IngredientID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsWithIngredients = `-- name: GetProductsWithIngredients :many
;

select p.id, p.name, p.category_id, iu.id, iu.quantity, iu.unit_id, iu.ingredient_id, iu.product_id, i.id, i.name, ip.id, ip.time_stamp, ip.price, ip.quantity, ip.unit_id, ip.ingredient_id
from products p
left join ingredient_usage iu on iu.product_id = p.id
left join ingredients i on i.id = iu.ingredient_id
left join
    ingredient_prices ip
    on ip.id = (
        select id
        from ingredient_prices as ip2
        where ip2.ingredient_id = i.id
        order by time_stamp desc
        limit 1
    )
`

type GetProductsWithIngredientsRow struct {
	ID             int64
	Name           string
	CategoryID     *int64
	ID_2           *int64
	Quantity       *float64
	UnitID         *int64
	IngredientID   *int64
	ProductID      *int64
	ID_3           *int64
	Name_2         *string
	ID_4           *int64
	TimeStamp      *int64
	Price          *float64
	Quantity_2     *float64
	UnitID_2       *int64
	IngredientID_2 *int64
}

func (q *Queries) GetProductsWithIngredients(ctx context.Context) ([]GetProductsWithIngredientsRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductsWithIngredients)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsWithIngredientsRow
	for rows.Next() {
		var i GetProductsWithIngredientsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CategoryID,
			&i.ID_2,
			&i.Quantity,
			&i.UnitID,
			&i.IngredientID,
			&i.ProductID,
			&i.ID_3,
			&i.Name_2,
			&i.ID_4,
			&i.TimeStamp,
			&i.Price,
			&i.Quantity_2,
			&i.UnitID_2,
			&i.IngredientID_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnits = `-- name: GetUnits :many
;

select id, name, base_unit_id, factor
from units
`

func (q *Queries) GetUnits(ctx context.Context) ([]Unit, error) {
	rows, err := q.db.QueryContext(ctx, getUnits)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Unit
	for rows.Next() {
		var i Unit
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.BaseUnitID,
			&i.Factor,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const putCategory = `-- name: PutCategory :one
;

insert into categories (name, vat)
values (?,?)
returning id, name, vat
`

type PutCategoryParams struct {
	Name string
	Vat  int64
}

func (q *Queries) PutCategory(ctx context.Context, arg PutCategoryParams) (Category, error) {
	row := q.db.QueryRowContext(ctx, putCategory, arg.Name, arg.Vat)
	var i Category
	err := row.Scan(&i.ID, &i.Name, &i.Vat)
	return i, err
}

const putIngredient = `-- name: PutIngredient :one
;

insert into ingredients (name)
values (?)
returning id, name
`

func (q *Queries) PutIngredient(ctx context.Context, name string) (Ingredient, error) {
	row := q.db.QueryRowContext(ctx, putIngredient, name)
	var i Ingredient
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const putIngredientPrice = `-- name: PutIngredientPrice :one
;

insert into ingredient_prices (ingredient_id, price, quantity, unit_id)
values (?, ?, ?, ?)
returning id, time_stamp, price, quantity, unit_id, ingredient_id
`

type PutIngredientPriceParams struct {
	IngredientID int64
	Price        float64
	Quantity     float64
	UnitID       int64
}

func (q *Queries) PutIngredientPrice(ctx context.Context, arg PutIngredientPriceParams) (IngredientPrice, error) {
	row := q.db.QueryRowContext(ctx, putIngredientPrice,
		arg.IngredientID,
		arg.Price,
		arg.Quantity,
		arg.UnitID,
	)
	var i IngredientPrice
	err := row.Scan(
		&i.ID,
		&i.TimeStamp,
		&i.Price,
		&i.Quantity,
		&i.UnitID,
		&i.IngredientID,
	)
	return i, err
}

const updateCategory = `-- name: UpdateCategory :one
;


update categories
set name=?, vat=?
where id=?
returning id, name, vat
`

type UpdateCategoryParams struct {
	Name string
	Vat  int64
	ID   int64
}

func (q *Queries) UpdateCategory(ctx context.Context, arg UpdateCategoryParams) (Category, error) {
	row := q.db.QueryRowContext(ctx, updateCategory, arg.Name, arg.Vat, arg.ID)
	var i Category
	err := row.Scan(&i.ID, &i.Name, &i.Vat)
	return i, err
}
